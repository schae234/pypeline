#!/usr/bin/python

from __future__ import print_function
import os
import sys
import numpy
import re
from optparse import OptionParser
from collections import defaultdict


class VCFFilter(object):
    def __init__(self):
        self.percentile = None
        self.field = None
        self.qual = None
        self.thresh = None
        self.union_positions = None
        self.map_positions = None
        self.out = sys.stdout
        self.log = sys.stderr
        self.skip_chroms = None
        self.num_call_sets = None

    def get_percentile_cutoff(self,vcf_file,perc):
        with open(vcf_file,'r') as file:
            quals = numpy.array(
                [float(line.split()[5]) for line in file if not line.startswith("#") ]
            )
        qual_cutoff = numpy.percentile(quals,perc)
        return qual_cutoff 

    def filter(self,vcf_file):
        ''' This method performs the filtering. It assumes you set up the filters ahead of time '''
        # Filter the vcf file
        with open(vcf_file,'r') as invcf:
            for line in invcf:
                if line.startswith('#'):
                    # headers always get printed
                    print(line,file=self.out,end="")
                else:
                    fields = line.split()
                    if self.skip_chroms and fields[0] in self.skip_chroms:
                        continue 
                    if self.qual and float(fields[5]) < self.thresh:
                        continue
                    if self.field and self.thresh:
                        field = re.search(str(';'+self.field+'=([^;]*)(;?)'),fields[7])
                        if field == None:
                            print("No {} field for variant {} {}".format(self.field,fields[0],fields[1]),file=self.log)
                        else:
                            if float(field.group(1)) < self.thresh:
                                continue
                    if self.union_positions and int(fields[1]) not in self.union_positions[fields[0]]:
                        continue
                    if self.map_positions and int(fields[1]) not in self.map_positions[fields[0]]:
                        continue
                    if self.num_call_sets:
                        sets = re.search(';set=([^;]*)(;?)',fields[7])
                        if sets == None:
                            print("No set found for {} {}".format(fields[0],fields[1]),file=self.log)
                        else:
                            if len(sets.group(1).split('-')) < self.num_call_sets or sets.group(1) == 'FilteredInAll':
                                continue
                    print(line, file=self.out ,end="")

    def populate_union(self,vcf_file):
        positions = defaultdict(list)
        with open(vcf_file,'r') as file:
            for line in file:
                if line.startswith('#'):
                    continue
                line = line.rstrip()
                line = line.split()
                positions[line[0]].append(int(line[1]))
        for chr in positions.keys():
            # covert to set for fast intersection checks
            positions[chr] = set(positions[chr])
        self.union_positions = positions

    def populate_map(self,map_file):
        positions = defaultdict(list)
        with open(map_file,'r') as file:
            for line in file:
                line=line.strip()
                chr,id,cm,pos = line.split()
                positions['chr'+chr].append(int(pos))
        for chr in positions.keys():
            # covert to set for fast intersection checks
            positions[chr] = set(positions[chr])
        self.map_positions = positions

def main(argv):
    parser = OptionParser()
    parser.add_option("--union_vcf", default = None, type=str, help="Additionally only match variants within another vcf")
    parser.add_option("--field", default=None, type=str, help="Used with percentile or threshold arguments to filter out based on a FIELD arg")
    parser.add_option("--qual", action="store_true", default=None, help="Used with percentile or threshold arguments to filter out based on a QUAL arg")
    parser.add_option("--thresh", default=None,type=float,help='filter out --field values under this threshold')
    parser.add_option("-p", "--percentile", default = 99, type = int,help="filter out --field values under this percentile")
    parser.add_option("-v", "--verbose", default = False, action="store_true",help="how much do you want to know?")
    parser.add_option('--map_file',type=str,default=None,help="Only include snps in Plink map file")
    parser.add_option('--skip_chrom',action="append",type=str,help="Skip variants on chroms. Can be specified multiple times")
    parser.add_option('--num_call_sets',type=float,help="the minimum number of call sets a variant must be called in")
    
    parser.add_option("-o",'--out', default=sys.stdout )
    options, args = parser.parse_args(argv) 

    # Create an empty filter and add based on options
    flt = VCFFilter()
    # Check to see if we are performing union checks
    if options.union_vcf != None:
        flt.populate_union(options.union_vcf)
    # Check for map based filters
    if options.map_file != None:
        flt.populate_map(options.map_file)
    # Check for chrom based filters
    if options.skip_chrom:
        flt.skip_chroms = set(options.skip_chrom)
    # Check for field based filters, can be either a thresh OR percentile, not both
    if options.field and (options.field or options.percentile):
        flt.field = options.field
        flt.thresh = options.thresh
        flt.percentile = options.percentile
    if options.qual:
        if not options.thresh and not options.percentile:
            exit("--qual requires --thresh or --percentile")
        flt.qual = options.qual
        flt.thresh = options.thresh
        flt.percentile = options.percentile
    if options.num_call_sets:
        flt.num_call_sets = options.num_call_sets
    if options.out != sys.stdout:
        flt.out = open(options.out,'w')

    # Process input files
    for filename in args:
        flt.filter(filename)


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
