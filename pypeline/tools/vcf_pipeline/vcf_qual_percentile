#!/usr/bin/python2

from __future__ import print_function
import os
import sys
import numpy
import re
from optparse import OptionParser
from collections import defaultdict


class VCFFilter(object):
    def __init__(self):
        self.percentile = None
        self.field = None
        self.qual = None
        self.thresh = None
        self.union_positions = None
        self.map_positions = None
        self.out = sys.stdout
        self.log_file = sys.stderr
        self.skip_chroms = None
        self.num_call_sets = None
        self.filter = None

    def get_percentile_cutoff(self,vcf_file,perc):
        ''' Return the field cutoff for a specific field cutoff ''' 
        with open(vcf_file,'r') as file:
            quals = numpy.array(
                [float(line.split()[5]) for line in file if not line.startswith("#") ]
            )
        qual_cutoff = numpy.percentile(quals,perc)
        return qual_cutoff 

    def process(self,vcf_file):
        ''' This method performs the filtering. It assumes you set up the filters ahead of time '''
        # Filter the vcf file
        with open(vcf_file,'r') as invcf:
            for line in invcf:
                if line.startswith('#'):
                    fields = line.split()
                    self.indivs = fields[9:]
                    # headers always get printed
                    print(line,file=self.out,end="")
                else:
                    fields = line.split()
                    # for now slip tri-allelic snps:
                    if ',' in fields[4]:
                        continue
                    if self.skip_chroms and fields[0] in self.skip_chroms:
                        continue 
                    if self.qual and float(fields[5]) < self.thresh:
                        continue
                    if self.field and self.thresh:
                        field = re.search(str(';?'+self.field+'=([^;]*)(;?)'),fields[7])
                        if field == None:
                            self.log("No {} field for variant {} {}".format(self.field,fields[0],fields[1]))
                        else:
                            if float(field.group(1)) < self.thresh:
                                continue
                    if self.union_positions and int(fields[1]) not in self.union_positions[fields[0]]:
                        continue
                    if self.map_positions and int(fields[1]) not in self.map_positions[fields[0]]:
                        continue
                    if self.num_call_sets:
                        sets = re.search(';?set=([^;]*)(;?)',fields[7])
                        if sets == None:
                            self.log("No set found for {} {}".format(fields[0],fields[1]))
                        else:
                            if len(sets.group(1).split('-')) < self.num_call_sets or sets.group(1) == 'FilteredInAll':
                                continue
                    if self.filter and not re.match(self.filter,fields[6]):
                        continue
        
                    print(line, file=self.out ,end="")

    def populate_intersect(self,vcf_file):
        self.log("Reading in union file: {}".format(vcf_file))
        positions = defaultdict(list)
        with open(vcf_file,'r') as file:
            for line in file:
                if line.startswith('#'):
                    continue
                line = line.rstrip()
                line = line.split()
                positions[line[0]].append(int(line[1]))
        num_vars_seen = 0
        for chr in positions.keys():
            # covert to set for fast intersection checks
            positions[chr] = set(positions[chr])
            num_vars_seen += len(positions[chr])
        self.log("Found {} variants in union file".format(num_vars_seen))
        self.union_positions = positions

    def populate_map(self,map_file):
        positions = defaultdict(list)
        with open(map_file,'r') as file:
            for line in file:
                line=line.strip()
                chr,id,cm,pos = line.split()
                positions['chr'+chr].append(int(pos))
        for chr in positions.keys():
            # covert to set for fast intersection checks
            positions[chr] = set(positions[chr])
        self.map_positions = positions

    def log(self,*args):
        print(*args,file=self.log_file)


def main(argv):
    parser = OptionParser()
    parser.add_option("--intersect_vcf", default = None, type=str, help="Only match variants within another vcf")
    parser.add_option("--exclude_vcf",default=None, type=str,help="Only match variants not within another vcf")
    parser.add_option("--filter",default=None, type=str,help="filter out variants that do not match based on FILTER field, e.g. LowQual")
    parser.add_option("--field", default=None, type=str, help="Used with percentile or threshold arguments to filter out based on a FIELD arg")
    parser.add_option("--qual", action="store_true", default=None, help="Used with percentile or threshold arguments to filter out based on a QUAL arg")
    parser.add_option("--thresh", default=None,type=float,help='filter out --field values under this threshold')
    parser.add_option("-p", "--percentile", default = None, type = int,help="filter out --field values under this percentile")
    parser.add_option("-v", "--verbose", default = False, action="store_true",help="how much do you want to know?")
    parser.add_option('--map_file',type=str,default=None,help="Only include snps in Plink map file")
    parser.add_option('--skip_chrom',action="append",type=str,help="Skip variants on chroms. Can be specified multiple times")
    parser.add_option('--num_call_sets',type=float,help="the minimum number of call sets a variant must be called in")
    
    parser.add_option("-o",'--out', default=sys.stdout )
    options, args = parser.parse_args(argv) 

    # Create an empty filter and add based on options
    flt = VCFFilter()
    flt.log("Starting Analysis...")
    # Check to see if we are performing union checks
    if options.intersect_vcf != None:
        flt.populate_intersect(options.intersect_vcf)
    # Check for map based filters
    if options.map_file != None:
        flt.populate_map(options.map_file)
    # Check for chrom based filters
    if options.skip_chrom:
        flt.skip_chroms = set(options.skip_chrom)
    # Check for field based filters, can be either a thresh OR percentile, not both
    if options.field and (options.field or options.percentile):
        flt.field = options.field
        flt.thresh = options.thresh
        flt.percentile = options.percentile
    # Check the threshold based filter
    if options.qual:
        if not options.thresh and not options.percentile:
            exit("--qual requires --thresh or --percentile")
        flt.qual = options.qual
        flt.thresh = options.thresh
    # Check for call set based filters
    if options.num_call_sets:
        flt.num_call_sets = options.num_call_sets
    # Check for percentile based filters
    if options.percentile:
        flt.qual = "QUAL"
        flt.thresh = flt.get_percentile_cutoff(args[0],options.percentile)
        print("QUAL THRESH: {}".format(flt.thresh),file=sys.stderr)
    if options.out != sys.stdout:
        flt.out = open(options.out,'w')
    # Check for FILTER based filters
    if options.filter:
        flt.filter = options.filter

    # Process input files
    for filename in args:
        flt.process(filename)

    flt.log("... analysis ended")

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
